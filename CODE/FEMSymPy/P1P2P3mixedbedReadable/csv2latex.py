"""
Python code to use csv files generated by CSVFileGenerator to generate latex 
that write up the terms of the matrix A in Au = b for the given integral of the
Finite Element Method. This file generates the latex used in the  
PDF (https://sites.google.com/view/jordanpitt/phd-thesis-resources/finite-element-integrals/pdf) 

by Jordan Pitt 11/10/2018
"""

"""
############################# IMPORTS #########################################
"""
import csv
from sympy import *
import csv



"""
########################## Code Body ###############################
"""

#
# ---------------- CSV File Read ----------------------------------
#
#termname determines which integral to write the matrix terms for
termname = "h2bxuxt"
x = Symbol('x')
filen = termname + ".csv"

Ints = []
Intvs = []
Names = []
with open(filen,'r') as file1:
     readfile = csv.reader(file1, delimiter = ',', quotechar='|', quoting=csv.QUOTE_MINIMAL)
     j = -1
     for row in readfile:       
         if (j >= 0):
            Ints.append(S(row[0]))
            lb= S(row[1])
            ub = S(row[2])
            Intvs.append(S(row[3]))
            Names.append(row[4:])

            
            
         j = j + 1

# n is the number of integrals in the CSV
n = len(Ints)

#m is the number of elements in the 3x3 matrix of A 
m = 9

#Since all the integrals have the same number of basis function combinations
# ni is the number of basis function combinations in a single element of A
ni = n/m
l = len(Names[0])
lm2 = l- 2

#Indexes of the matrix element, in order in which they are used
indexes = ['0,0','0,1','0,2','1,0','1,1','1,2','2,0','2,1','2,2']

#List of the basis function terms and their associated quantities
# since we are only doing the elements of the matrix A, then psi is only 
# associated with the water depth. Also only h and derivatives of b are the 
# only functions that arent the test function that are in the integrals of A
psiterms = ["psijm1o2p","psijp1o2m"]
hterms = ['hjmhp','hjphm']

dgammaterms  = ["dgammajmh","dgammajms","dgammajps","dgammajph"]
bterms = ['bjmh','bjms','bjps','bjph']

#Iterate over the number of elements in the matrix
for i in range(m):
    
    #First part of string is the LHS
    string = "\\begin{multline*} A_{" + indexes[i]+"}" + " = " + termmult + ""
    
    #Now we produce the RHS of the equation
    #Iterate over number of integrals for each element: ni
    for j in range(ni):
        termN = ""
        
        #iterate over all basis functions except the last one which is just
        # the test function
        for k in range(lm2):
            
            #If the current basis function name is in psiterms, write the 
            # corresponding h term
            if(Names[ni*i + j][k] in psiterms):                
                indc = psiterms.index(Names[ni*i + j][k])
                termN = termN + " " + hterms[indc]
                
            #If the current basis function name is not in psiterms it must be
            # in dgamma terms so write the corresponding b term
            else:
                indc = dgammaterms.index(Names[ni*i + j][k])
                termN = termN + " " + bterms[indc]
        
        #If the current integral is non-zero, it must be some fraction        
        if(Intvs[ni*i + j] != 0):
            
            #write this fraction with the correct sign
            frac = str(Intvs[ni*i + j])   
            fracp = frac.split("/")
            nfrac = "\\frac{"+str(abs(S(fracp[0])))+"}{"+fracp[1]+"}"
            
            if(sign(S(fracp[0])) == -1):
                sign1 = "-"
            else:
                sign1 = "+"
            
        else:
            #Current integral is zero, so just write 0 as the coefficient
            nfrac =str(Intvs[ni*i + j]) 
            
        #if the current term is divisible by 3 start a newline in latex
        # this was found to be a good limit in practice, else just add the term
        if(j > 0 and j%3 == 0):
            string = string + "\\\\" + (j>0)*sign1 +  nfrac   + termN 
        else:
            string = string + (j>0)*sign1 +  nfrac   + termN
    
    #now go through and reaplce all temporary names with their latex equivalents
    # and end the multline    
    string = string + ","
    string = string.replace("hjmhp","h_{j-1/2}^+")   
    string = string.replace("hjphm","h_{j+1/2}^-") 
    string = string.replace("bjmh","b_{j-1/2}")   
    string = string.replace("bjms","b_{j-1/6}") 
    string = string.replace("bjph","b_{j+1/2}")   
    string = string.replace("bjps","b_{j+1/6}") 
    string = string + " \\end{multline*}"
    print("")
    print(string)


    