"""
Python code to use csv files generated by CSVFileGenerator to generate C like 
code for the terms of the matrix A in Au = b for the given integral of the
Finite Element Method. This file generates the latex used in the  
PDF (https://sites.google.com/view/jordanpitt/phd-thesis-resources/finite-element-integrals/text-c-like-program) 

by Jordan Pitt 11/10/2018
"""

"""
############################# IMPORTS #########################################
"""
import csv
from sympy import *


#
# ---------------- CSV File Read ----------------------------------
#
#termname determines which integral to write the matrix terms for
termname = "hbx2ut"
termmult = "2*idx*"
x = Symbol('x')
filen = termname + ".csv"

Ints = []
Intvs = []
Names = []
with open(filen,'r') as file1:
     readfile = csv.reader(file1, delimiter = ',', quotechar='|', quoting=csv.QUOTE_MINIMAL)
     j = -1
     for row in readfile:       
         if (j >= 0):
            Ints.append(S(row[0]))
            lb= S(row[1])
            ub = S(row[2])
            Intvs.append(S(row[3]))
            Names.append(row[4:])

            
            
         j = j + 1

# n is the number of integrals in the CSV
n = len(Ints)

#m is the number of elements in the 3x3 matrix of A 
m = 9

#Since all the integrals have the same number of basis function combinations
# ni is the number of basis function combinations in a single element of A
ni = n/m
l = len(Names[0])
lm2 = l- 2

#Indexes of the matrix element, in order in which they are used
indexes = ['0,0','0,1','0,2','1,0','1,1','1,2','2,0','2,1','2,2']

#List of the basis function terms and their associated quantities
# since we are only doing the elements of the matrix A, then psi is only 
# associated with the water depth. Also only h and derivatives of b are the 
# only functions that arent the test function that are in the integrals of A
psiterms = ["psijm1o2p","psijp1o2m"]
hterms = ['hjmhp','hjphm']

dgammaterms  = ["dgammajmh","dgammajms","dgammajps","dgammajph"]
bterms = ['bjmh','bjms','bjps','bjph']

#Iterate over the number of elements in the matrix
for i in range(m):
    #variable name to be assigned
    string = termname+ "a" + indexes[i] + " = " + termmult + "("
    
    #Now we produce the RHS of the equation
    #Iterate over number of integrals for each element: ni, terms comprising
    # each element
    for j in range(ni):
        
        termN = ""
        
        #iterate over all basis functions except the last one which is just
        # the test function
        for k in range(lm2):
            
            #If the current basis function name is in psiterms, write the 
            # corresponding h term
            if(Names[ni*i + j][k] in psiterms):                
                indc = psiterms.index(Names[ni*i + j][k])
                termN = termN + "*" + hterms[indc]
                
            #If the current basis function name is not in psiterms it must be
            # in dgamma terms so write the corresponding b term
            else:
                indc = dgammaterms.index(Names[ni*i + j][k])
                termN = termN + "*" + bterms[indc]
         
        #If the current integral is non-zero, it must be some fraction  
        if(Intvs[ni*i + j] != 0):
            frac = str(Intvs[ni*i + j])   
            fracp = frac.split("/")
            nfrac = fracp[0] + ".0/"+fracp[1]
        else:
            #Current integral is zero, so just write 0 as the coefficient
            nfrac =str(Intvs[ni*i + j]) 
        
        string = string + "(" + nfrac + ")" + termN + (j<ni-1)*"+"
        
    string = string + ")"
        
    print("")
    print(string)


    